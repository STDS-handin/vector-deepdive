{
  "hash": "6ce989b3c319d9d9b574f514194f93d4",
  "result": {
    "engine": "knitr",
    "markdown": "# Task 1\n\n---\n\nDownload the datasets `swissTLM3D` and `swissboundaries3d` from swisstopo. Using `swissTLM3d` and `swissboundaries3d`, calculate the percentage of area covered by forest *per canton*. Visualize the results (in a map and / or a plot).\n\nRender the document using `quarto preview`. Publish your result using `quarto publish gh-pages`\n\n# Solution 1\n\n---\n\nFirst, the data must be read in. I downloaded the GeoPackages, which can be loaded into memory using the `st_read()` function. There are multiple layers in the GeoPackages, so one needs to explicitly state which one should be loaded. For the canton boundaries, we need the layer `\"tlm_kantonsgebiet\"`, and for the forest data, we need the layer `\"tlm_bb_bodenbedeckung\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(units)\nlibrary(tictoc)\nlibrary(duckdb)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we read in the canton polynomials\ncanton_polygons <- st_read(\n  \"./data/swissBOUNDARIES3D_1_5_LV95_LN02.gpkg\",\n  layer = \"tlm_kantonsgebiet\"\n)\n\n\n# and also the ground cover polynomials\nground_cover_polys <- st_read(\n  \"./data/SWISSTLM3D_2025.gpkg\", \n  layer = \"tlm_bb_bodenbedeckung\"\n)\n```\n:::\n\n\nThe layer `\"tlm_kantonsgebiet\"` only contains the canton polygons. In the layer `\"tlm_bb_bodenbedeckung\"`, there is a range of different landcover classes. If we only want forest polygons, some filtering needs to be conducted. An overview of the different classes can be obtained by looking at the unique values in the `\"objektart\"` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the categories \nground_cover_polys %>%\n  pull(\"objektart\") %>%\n  unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Lockergestein\"        \"Wald\"                 \"Feuchtgebiet\"        \n [4] \"Lockergestein locker\" \"Fels\"                 \"Gebueschwald\"        \n [7] \"Stehende Gewaesser\"   \"Gehoelzflaeche\"       \"Schneefeld Toteis\"   \n[10] \"Fels locker\"          \"Fliessgewaesser\"      \"Felsbloecke locker\"  \n[13] \"Wald offen\"           \"Gletscher\"            \"Felsbloecke\"         \n```\n\n\n:::\n:::\n\n\nIt looks like there are actually three forest-like categories: `\"Wald\"`, `\"Wald offen\"`, and `\"Gehoelzflaeche\"`. From comparison with the results of Task 2, I know that here only the class `\"Wald\"` should be selected. However, this is generally open to individual judgment, and whether `\"Wald offen\"` and `\"Gehoelzflaeche\"` should be included or excluded is not explicitly determined in this context. Filtering over non-geometrical columns can be done just like with a standard dataframe. I personally prefer using the `tidyverse` package and therefore use the `filter()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# filter for all entries of type \"Wald\"\nforest_polys <- ground_cover_polys %>%\n  filter(objektart == \"Wald\")\n```\n:::\n\n\nNow the intersection between every canton and the forest polygons needs to be determined. Next, the area of the newly created forest polygons needs to be summed up. I first tried to implement this using spatial joins and so on, to perform the calculation for all cantons in one step. But my PC cannot handle the memory requirements. I therefore opted for a strategy of performing the intersection and aggregation for every canton sequentially using a mapping procedure. This has the advantage that the calculations do not all happen at once, and my memory is sufficient.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_area_per_canton <- function(canton_name, canton_polys, forest_polys) {\n  # get the row featuring the canton. This row contains the geometry of the canton\n  target_canton <- canton_polys %>%\n    filter(name == canton_name)\n\n  # intersect the forest polynomials of all of switzerland with the canton to get a new set of polynomials\n  # these polynomials display the forested area in this canton (the canton polynomial acted like a cooky cutter)\n  forest_polys_intersected <- st_intersection(forest_polys, target_canton)\n\n  # next sum up the area of all the forest polynomials\n  forested_area_per_canton <- forest_polys_intersected %>%\n    st_area() %>%\n    sum()\n\n  # lastly we return a named list with the canton name and the summed area\n  return(\n    list(name = canton_name, forested_area = forested_area_per_canton)\n  )\n}\n\n# get all the canton names\ncanton_names <- canton_polygons %>%\n  pull(name) %>%\n  unique()\n\n# using map to apply the above defined function to all the cantons sequentially\nresults_list <- map(\n  canton_names,\n  ~ calculate_area_per_canton(.x, canton_polygons, forest_polys),\n  .progress = \"Calculation Progress\"\n)\n\n# the resulting nested lists can be combined to a dataframe using bind rows\nresults_df <- results_list %>%\n  bind_rows()\n```\n:::\n\n\nNow we have the cantons with their forested area. All that is left to do is to join the result with the `canton_polygons` dataframe. This then allows us to calculate the relative surface coverage of forest for every canton. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# then we can join the calculated areas with the geometries of the canton\ncanton_forest_sf <- canton_polygons %>%\n  left_join(results_df, by = \"name\") %>%\n  mutate(\n    # we also calculate the total area of forest now to get percentage values later\n    total_canton_area = st_area(geom),\n\n    # Calculate the percentage (Forest Area / Total Area * 100)\n    forest_pct = as.numeric(forested_area / total_canton_area) * 100\n  )\n```\n:::\n\n\nLastly, some plotting is needed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the PERCENTAGE on the map\ntm_shape(canton_forest_sf) +\n  tm_polygons(\n    col = \"forest_pct\",\n    style = \"jenks\",\n    palette = \"Greens\",\n    title = \"Forest Cover (%)\"\n  ) +\n  tm_layout(\n    main.title = \"Percentage of Forest Cover by Swiss Canton\",\n    frame = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncanton_forest_sf %>%\n  st_drop_geometry() %>%\n  select(name, forest_pct) %>%\n  arrange(desc(forest_pct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     name forest_pct\n1                  Ticino   42.48994\n2            Schaffhausen   42.03183\n3               Solothurn   40.48123\n4                    Jura   40.11224\n5        Basel-Landschaft   39.13295\n6                Obwalden   35.50259\n7                  Aargau   34.89646\n8               Neuchâtel   34.19467\n9  Appenzell Ausserrhoden   31.55630\n10              Nidwalden   30.28705\n11                 Schwyz   29.83511\n12                   Vaud   29.41253\n13                 Zürich   29.10960\n14                   Bern   27.90532\n15  Appenzell Innerrhoden   27.37947\n16                 Luzern   27.21693\n17             St. Gallen   26.45942\n18                    Zug   26.12384\n19               Fribourg   24.98699\n20                 Glarus   24.25139\n21             Graubünden   22.72649\n22                Thurgau   20.06883\n23                 Valais   20.05983\n24                    Uri   14.31376\n25            Basel-Stadt   12.58995\n26                 Genève   11.59034\n```\n\n\n:::\n:::\n\n\n# Task 2\n\n---\n\nWe have prepared a duckdb database on moodle (`wald-kantone.duckdb`). This database contains two layers: The forest data from `swissTLM3D` and the canton boundaries from `swissBOUNDARIES3D`.\n\nUse this dataset and with the help of DuckDB in practice, recreate [Task 1](#task-1) and measure the execution time using the R package `tictoc`.\n\nCompare the execution time with [Task 1](#task-1). Discuss!\n\n# Solution 2\n\n---\n\nFor this, I first installed DuckDB with its command-line interface:\n[https://duckdb.org/install/?platform=linux&environment=cli](https://duckdb.org/install/?platform=linux&environment=cli)\n\nThen I created a set of views directly in the CLI. For this, I largely followed the SQL queries provided in the DuckDB slides.\n\nFirst, I created a view that performs an intersection yielding forest polygons that overlap with the various canton polygons and then gets their area.\n\n```sql\nCREATE VIEW forest_per_canton AS\nSELECT\n  name,\n  st_area(st_intersection(wald.geom, kantone.geom)) AS wald_area\nFROM\n  wald,\n  kantone\nWHERE\n  st_intersects(wald.geom, kantone.geom);\n```\n\nSecondly, I used grouping to sum all forest areas associated with a specific canton together to obtain the total forested area per canton. This result I also stored in a view:\n\n```sql\nCREATE VIEW forest_sum_canton AS\nSELECT\n  name,\n  sum(wald_area) AS wald_area\nFROM\n  forest_per_canton\nGROUP BY\n  name;\n```\n\nLastly, I joined the forest sum view with the canton table to then calculate the percentual forest surface coverage. This was again used to define a view\n\n```sql\nCREATE VIEW cantonal_forest_fractions AS\nSELECT\n  kantone.name,\n  (forest_sum_canton.wald_area / kantone.area) * 100 AS forest_fraction\nFROM\n  forest_sum_canton\nLEFT JOIN\n  kantone\nON\n  forest_sum_canton.name = kantone.name\nORDER BY\n  forest_fraction DESC;\n```\n\nThis view can then be loaded into R using the `duckdb` R package. Here, the timing can be conducted with `tictoc`, since a view is not materialized and will get computed as soon as the R code calls the view.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- dbConnect(\n  duckdb(),\n  dbdir = \"./data/wald-kantone.duckdb\",\n  read_only = TRUE\n)\n\ndbExecute(con, \"INSTALL spatial;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ndbExecute(con, \"LOAD spatial;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ntictoc::tic(\"DuckDB Computation\")\n\ncanton_frac <- dbReadTable(con, \"cantonal_forest_fractions\")\n\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDuckDB Computation: 110.5 sec elapsed\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(canton_frac)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     name forest_fraction\n1                  Ticino        42.48997\n2            Schaffhausen        42.03280\n3               Solothurn        40.47207\n4                    Jura        39.86165\n5        Basel-Landschaft        39.12242\n6                Obwalden        35.50370\n7                  Aargau        34.89662\n8               Neuchâtel        34.19347\n9  Appenzell Ausserrhoden        31.55623\n10              Nidwalden        30.28705\n11                 Schwyz        29.83506\n12                   Vaud        29.41998\n13                 Zürich        29.11433\n14                   Bern        27.98088\n15  Appenzell Innerrhoden        27.37958\n16                 Luzern        27.21733\n17             St. Gallen        26.45973\n18                    Zug        26.12384\n19               Fribourg        24.97658\n20                 Glarus        24.25160\n21             Graubünden        22.72659\n22                Thurgau        20.06853\n23                 Valais        19.90037\n24                    Uri        14.31376\n25            Basel-Stadt        12.65465\n26                 Genève        11.64690\n```\n\n\n:::\n:::\n\n\nLet's compare the execution time to the standard R code from Task 1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(\"Base R Computation\")\n\nresults_list <- map(\n  canton_names,\n  ~ calculate_area_per_canton(.x, canton_polygons, forest_polys),\n  .progress = \"Calculation Progress\"\n)\n\nresults_df <- results_list %>%\n  bind_rows()\n\ncanton_forest_sf <- canton_polygons %>%\n  left_join(results_df, by = \"name\") %>%\n  mutate(\n    total_canton_area = st_area(geom),\n    forest_pct = as.numeric(forested_area / total_canton_area) * 100\n  )\n\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBase R Computation: 184.594 sec elapsed\n```\n\n\n:::\n\n```{.r .cell-code}\n# Print clean dataframe without geometry\ncanton_forest_sf %>%\n  st_drop_geometry() %>%\n  select(name, forest_pct) %>%\n  arrange(desc(forest_pct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     name forest_pct\n1                  Ticino   42.48994\n2            Schaffhausen   42.03183\n3               Solothurn   40.48123\n4                    Jura   40.11224\n5        Basel-Landschaft   39.13295\n6                Obwalden   35.50259\n7                  Aargau   34.89646\n8               Neuchâtel   34.19467\n9  Appenzell Ausserrhoden   31.55630\n10              Nidwalden   30.28705\n11                 Schwyz   29.83511\n12                   Vaud   29.41253\n13                 Zürich   29.10960\n14                   Bern   27.90532\n15  Appenzell Innerrhoden   27.37947\n16                 Luzern   27.21693\n17             St. Gallen   26.45942\n18                    Zug   26.12384\n19               Fribourg   24.98699\n20                 Glarus   24.25139\n21             Graubünden   22.72649\n22                Thurgau   20.06883\n23                 Valais   20.05983\n24                    Uri   14.31376\n25            Basel-Stadt   12.58995\n26                 Genève   11.59034\n```\n\n\n:::\n:::\n\n\n### Why is the database faster:\n\nThe reason for this, is that there is a spatial index set up for the forest table and for the canton table (the second index i setup myself). Due to these indices, the underlying querry optimizer\ncan eliminate non overlaping geometries cheaply by checking wheter bounding boxes overlap. If they do not overlap, then we do not even have to start to\nperform  the `st_intersects` operation for the two geometries in question.\n\nOne can check the existance of the indices by looking at the Index tables\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"SELECT sql FROM duckdb_indexes();\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                                      sql\n1 CREATE INDEX kantone_idx ON kantone USING RTREE (geom);\n2       CREATE INDEX wald_idx ON wald USING RTREE (geom);\n```\n\n\n:::\n:::\n\n\n\n# Task 3\n\n---\n\nWithout consulting external help, try and specify the DE-9IM string for the queen and bishop's.\n\nConcentrate on the boundary-boundary intersection. Note:\n\n* No intersection: `F`\n* Point intersection: `0`\n* Line intersetion: `1`\n* Any intersection: `*`\n\nThe 3x3 \"chessboard\" is available on moodle.\n\n\n# Solution 3\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"SELECT sql FROM duckdb_indexes();\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                                      sql\n1 CREATE INDEX kantone_idx ON kantone USING RTREE (geom);\n2       CREATE INDEX wald_idx ON wald USING RTREE (geom);\n```\n\n\n:::\n:::\n\n\n## Bishop\n\nThe bishop is very similar to the rook. For the rook we encoded, that the two polygons got to interact\nwith their boundaries in a way, so that a line is formed. This is done by placing a 1 at the boundary-boundary field of the\nDE-9IM string.\n\nIn the case of the bishop we are also interested in how the boundaries of the two polygons interact. Here the boundaries\nof the two polygons must interact in a way, so that a point is formed. This, because the bishop can only move to fields that\ntouch his current field at the corner => so only one touching point\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"SELECT sql FROM duckdb_indexes();\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                                      sql\n1 CREATE INDEX kantone_idx ON kantone USING RTREE (geom);\n2       CREATE INDEX wald_idx ON wald USING RTREE (geom);\n```\n\n\n:::\n:::\n\n\n\nThe queen is a fusion between the rooks case and the bishops case. Here the polygon boundaries must either interact in a way\nso that a point is formed or a line is formed. We can represent this case with the lether T. This letter incodes that there has to\nbe a interaction between the boudaries (they have to touch) but it does not matter wheter this only results in a point or a line.\nSo for the queens case we need\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbGetQuery(con, \"SELECT sql FROM duckdb_indexes();\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                                                      sql\n1 CREATE INDEX kantone_idx ON kantone USING RTREE (geom);\n2       CREATE INDEX wald_idx ON wald USING RTREE (geom);\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}