# Task 1

---

Download the datasets `swissTLM3D` and `swissboundaries3d` from swisstopo. Using `swissTLM3d` and `swissboundaries3d`,
calculate the percentage of area covered by forest *per canton*. Visualize the results (in a map and / or a plot).

Render the document using `quarto preview`. Publish your result using `quarto publish gh-pages`

# Solution 1

---

First, the data must be read in. I downloaded the GeoPackages, which can be loaded into memory using the `st_read()` function. 
There are multiple layers in the GeoPackages, so one needs to explicitly state which one should be loaded. For the canton boundaries, we need the layer `"tlm_kantonsgebiet"`,
and for the forest data, we need the layer `"tlm_bb_bodenbedeckung"`.

```{r}
#| message: false
#| warning: false

library(tidyverse)
library(sf)
library(tmap)
library(units)
library(tictoc)
library(duckdb)
```

```{r}
#| message: false
#| warning: false
#| results: hide

# we read in the canton polynomials
canton_polygons <- st_read(
  "./data/swissBOUNDARIES3D_1_5_LV95_LN02.gpkg",
  layer = "tlm_kantonsgebiet"
)


# and also the ground cover polynomials
ground_cover_polys <- st_read(
  "./data/SWISSTLM3D_2025.gpkg", 
  layer = "tlm_bb_bodenbedeckung"
)
```

The layer `"tlm_kantonsgebiet"` only contains the canton polygons. 
In the layer `"tlm_bb_bodenbedeckung"`, there is a range of different landcover classes. 
If we only want forest polygons, some filtering needs to be conducted.
An overview of the different classes can be obtained by looking at the unique values in the `"objektart"` column.

```{r}

# get the categories 
ground_cover_polys %>%
  pull("objektart") %>%
  unique()
```

It looks like there are actually three forest-like categories: `"Wald"`, `"Wald offen"`, and `"Gehoelzflaeche"`. From comparison with the results of Task 2, I know that here only the class `"Wald"` should be selected. However, this is generally open to individual judgment, and whether `"Wald offen"` and `"Gehoelzflaeche"` should be included or excluded is not explicitly determined in this context. Filtering over non-geometrical columns can be done just like with a standard dataframe. I personally prefer using the `tidyverse` package and therefore use the `filter()` function.

```{r}

# filter for all entries of type "Wald"
forest_polys <- ground_cover_polys %>%
  filter(objektart == "Wald")
```

Now the intersection between every canton and the forest polygons needs to be determined.
Next, the area of the newly created forest polygons needs to be summed up. 
I first tried to implement this using spatial joins and so on, to perform the calculation for all cantons in one step. 
But my PC cannot handle the memory requirements. I therefore opted for a strategy of performing the intersection and aggregation for every canton sequentially using a mapping procedure. 
This has the advantage that the calculations do not all happen at once, and my memory is sufficient.

```{r}
#| message: false
#| warning: false

calculate_area_per_canton <- function(canton_name, canton_polys, forest_polys) {
  # get the row featuring the canton. This row contains the geometry of the canton
  target_canton <- canton_polys %>%
    filter(name == canton_name)

  # intersect the forest polynomials of all of switzerland with the canton to get a new set of polynomials
  # these polynomials display the forested area in this canton (the canton polynomial acted like a cooky cutter)
  forest_polys_intersected <- st_intersection(forest_polys, target_canton)

  # next sum up the area of all the forest polynomials
  forested_area_per_canton <- forest_polys_intersected %>%
    st_area() %>%
    sum()

  # lastly we return a named list with the canton name and the summed area
  return(
    list(name = canton_name, forested_area = forested_area_per_canton)
  )
}

# get all the canton names
canton_names <- canton_polygons %>%
  pull(name) %>%
  unique()

# using map to apply the above defined function to all the cantons sequentially
results_list <- map(
  canton_names,
  ~ calculate_area_per_canton(.x, canton_polygons, forest_polys),
  .progress = "Calculation Progress"
)

# the resulting nested lists can be combined to a dataframe using bind rows
results_df <- results_list %>%
  bind_rows()
```

Now we have the cantons with their forested area. 
All that is left to do is to join the result with the `canton_polygons` dataframe. This then allows us to calculate the relative surface coverage of forest for every canton. 

```{r}
# then we can join the calculated areas with the geometries of the canton
canton_forest_sf <- canton_polygons %>%
  left_join(results_df, by = "name") %>%
  mutate(
    # we also calculate the total area of forest now to get percentage values later
    total_canton_area = st_area(geom),

    # Calculate the percentage (Forest Area / Total Area * 100)
    forest_pct = as.numeric(forested_area / total_canton_area) * 100
  )
```

Lastly, some plotting is needed.

```{r}
#| message: false
#| warning: false

# Plot the PERCENTAGE on the map
tm_shape(canton_forest_sf) +
  tm_polygons(
    col = "forest_pct",
    style = "jenks",
    palette = "Greens",
    title = "Forest Cover (%)"
  ) +
  tm_layout(
    main.title = "Percentage of Forest Cover by Swiss Canton",
    frame = FALSE
  )


canton_forest_sf %>%
  st_drop_geometry() %>%
  select(name, forest_pct) %>%
  arrange(desc(forest_pct))
```

# Task 2

---

We have prepared a duckdb database on moodle (`wald-kantone.duckdb`). This database contains two layers: The forest data from `swissTLM3D` and the canton boundaries from `swissBOUNDARIES3D`.

Use this dataset and with the help of DuckDB in practice, recreate [Task 1](#task-1) and measure the execution time using the R package `tictoc`.

Compare the execution time with [Task 1](#task-1). Discuss!

# Solution 2

---

For this, I first installed DuckDB with its command-line interface:
[https://duckdb.org/install/?platform=linux&environment=cli](https://duckdb.org/install/?platform=linux&environment=cli)

Then I created a set of views directly in the CLI. For this, I largely followed the SQL queries provided in the DuckDB slides.

First, I created a view that performs an intersection yielding forest polygons that overlap with the various canton polygons and then gets their area.

```sql
CREATE VIEW forest_per_canton AS
SELECT
  name,
  st_area(st_intersection(wald.geom, kantone.geom)) AS wald_area
FROM
  wald,
  kantone
WHERE
  st_intersects(wald.geom, kantone.geom);
```

Secondly, I used grouping to sum all forest areas associated with a specific canton together to obtain the total forested area per canton. This result I also stored in a view:

```sql
CREATE VIEW forest_sum_canton AS
SELECT
  name,
  sum(wald_area) AS wald_area
FROM
  forest_per_canton
GROUP BY
  name;
```

Lastly, I joined the forest sum view with the canton table to then calculate the percentual forest surface coverage. This was again used to define a view

```sql
CREATE VIEW cantonal_forest_fractions AS
SELECT
  kantone.name,
  (forest_sum_canton.wald_area / kantone.area) * 100 AS forest_fraction
FROM
  forest_sum_canton
LEFT JOIN
  kantone
ON
  forest_sum_canton.name = kantone.name
ORDER BY
  forest_fraction DESC;
```

This view can then be loaded into R using the `duckdb` R package. Here, the timing can be conducted with `tictoc`, since a view is not materialized and will get computed as soon as the R code calls the view.

```{r}
#| message: false
#| warning: false

con <- dbConnect(
  duckdb(),
  dbdir = "./data/wald-kantone.duckdb",
  read_only = TRUE
)

dbExecute(con, "INSTALL spatial;")
dbExecute(con, "LOAD spatial;")

tictoc::tic("DuckDB Computation")

canton_frac <- dbReadTable(con, "cantonal_forest_fractions")

tictoc::toc()

print(canton_frac)
```

Let's compare the execution time to the standard R code from Task 1:

```{r}
#| message: false
#| warning: false

tictoc::tic("Base R Computation")

results_list <- map(
  canton_names,
  ~ calculate_area_per_canton(.x, canton_polygons, forest_polys),
  .progress = "Calculation Progress"
)

results_df <- results_list %>%
  bind_rows()

canton_forest_sf <- canton_polygons %>%
  left_join(results_df, by = "name") %>%
  mutate(
    total_canton_area = st_area(geom),
    forest_pct = as.numeric(forested_area / total_canton_area) * 100
  )

tictoc::toc()

# Print clean dataframe without geometry
canton_forest_sf %>%
  st_drop_geometry() %>%
  select(name, forest_pct) %>%
  arrange(desc(forest_pct))
```

### Why is the database faster:

The reason for this, is that there is a spatial index set up for the forest table and for the canton table (the second index I setup myself). Due to these indices, the underlying querry optimizer
can eliminate non overlaping geometries cheaply by checking wheter bounding boxes overlap. If they do not overlap, then we do not even have to start to
perform  the `st_intersects` operation for the two geometries in question.

One can check the existance of the indices by looking at the Index tables




```{r}
dbGetQuery(con, "SELECT sql FROM duckdb_indexes();")
```


# Task 3

---

Without consulting external help, try and specify the DE-9IM string for the queen and bishop's.

Concentrate on the boundary-boundary intersection. Note:

* No intersection: `F`
* Point intersection: `0`
* Line intersetion: `1`
* Any intersection: `*`

The 3x3 "chessboard" is available on moodle.


# Solution 3

Both the bishop's case and the queen's case are very similar to the rook's case. The logic remains largely the same. 
We only need to adjust how the boundary-to-boundary interaction between the current field and the neighboring fields is defined.
So only one letter in the DE-9IM string has to be adjusted.

---

```{r}

#| include: false

grid_orig <- st_read(
  "./data/chessboard.gpkg",
   layer = "grid_orig"
  )

grid_dest <- st_read(
  "./data/chessboard.gpkg",
   layer = "grid_dest"

)


st_rook <- \(x, y) st_relate(x, y, pattern = "F***1****")

grid_rook <- grid_dest[grid_orig, , op = st_rook] |> 
  st_sample(1000, type = "hexagonal",by_polygon = TRUE)


st_bishop <- \(x, y) st_relate(x, y, pattern = "F***0****")

grid_bishop <- grid_dest[grid_orig, , op = st_bishop] |> 
  st_sample(1000, type = "hexagonal",by_polygon = TRUE)


st_queen <- \(x, y) st_relate(x, y, pattern = "F***T****")

grid_queen <- grid_dest[grid_orig, , op = st_queen] |> 
  st_sample(1000, type = "hexagonal",by_polygon = TRUE)


```

## Bishop

The bishop's case is very similar to the rook's. For the rook, we specified that the two polygons must interact along their boundaries to form a line. 
This was done by placing a 1 in the boundary-boundary position of the DE-9IM string.

In the case of the bishop, we are also focused on how the boundaries interact. 
However, here they must touch in a way that forms only a point. This represents the bishop’s movement, as it
can only move to fields that touch its current field at the corners—resulting in a single shared point.


```{r}

#| echo: false

# --- 1. BISHOP VISUALIZATION ---
plot(st_geometry(grid_dest), col = "#8fbc8f")
plot(st_geometry(grid_orig), col = "#c8bfe7", add = TRUE)


dots_bishop <- grid_dest[grid_orig, , op = st_bishop] |> 
  st_sample(1000, type = "hexagonal", by_polygon = TRUE)

plot(st_geometry(dots_bishop), pch = 20, cex = 0.5, add = TRUE)
text(st_coordinates(st_centroid(grid_orig)), labels = "♗", cex = 10)

```

The queen is a fusion of the rook and the bishop. In this case, the polygon boundaries can interact to form either a point or a line.
 We represent this using the letter T. This letter encodes that there must be an interaction between the boundaries (they have to touch),
but it does not matter whether that interaction results in a point or a line.

```{r}

#| echo: false

# --- 2. QUEEN VISUALIZATION ---
plot(st_geometry(grid_dest), col = "#8fbc8f")
plot(st_geometry(grid_orig), col = "#c8bfe7", add = TRUE)


dots_queen <- grid_dest[grid_orig, , op = st_queen] |> 
  st_sample(1000, type = "hexagonal", by_polygon = TRUE)

plot(st_geometry(dots_queen), pch = 20, cex = 0.5, add = TRUE)
text(st_coordinates(st_centroid(grid_orig)), labels = "♕", cex = 10)

```

